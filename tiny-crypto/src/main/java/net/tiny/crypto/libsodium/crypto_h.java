// Generated by jextract

package net.tiny.crypto.libsodium;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class crypto_h  {

    public static final OfByte C_CHAR = JAVA_BYTE;
    public static final OfShort C_SHORT = JAVA_SHORT;
    public static final OfInt C_INT = JAVA_INT;
    public static final OfLong C_LONG = JAVA_LONG;
    public static final OfLong C_LONG_LONG = JAVA_LONG;
    public static final OfFloat C_FLOAT = JAVA_FLOAT;
    public static final OfDouble C_DOUBLE = JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = RuntimeHelper.POINTER;
    public static MethodHandle sodium_init$MH() {
        return RuntimeHelper.requireNonNull(constants$0.const$1,"sodium_init");
    }
    /**
     * {@snippet :
     * int sodium_init();
     * }
     */
    public static int sodium_init() {
        var mh$ = sodium_init$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle crypto_hash_sha256$MH() {
        return RuntimeHelper.requireNonNull(constants$0.const$3,"crypto_hash_sha256");
    }
    /**
     * {@snippet :
     * int crypto_hash_sha256(unsigned char* out, unsigned char* in, unsigned long long inlen);
     * }
     */
    public static int crypto_hash_sha256(MemorySegment out, MemorySegment in, long inlen) {
        var mh$ = crypto_hash_sha256$MH();
        try {
            return (int)mh$.invokeExact(out, in, inlen);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle crypto_kdf_hkdf_sha256_extract$MH() {
        return RuntimeHelper.requireNonNull(constants$0.const$5,"crypto_kdf_hkdf_sha256_extract");
    }
    /**
     * {@snippet :
     * int crypto_kdf_hkdf_sha256_extract(unsigned char prk[32], unsigned char* salt, size_t salt_len, unsigned char* ikm, size_t ikm_len);
     * }
     */
    public static int crypto_kdf_hkdf_sha256_extract(MemorySegment prk, MemorySegment salt, long salt_len, MemorySegment ikm, long ikm_len) {
        var mh$ = crypto_kdf_hkdf_sha256_extract$MH();
        try {
            return (int)mh$.invokeExact(prk, salt, salt_len, ikm, ikm_len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle crypto_kdf_hkdf_sha256_expand$MH() {
        return RuntimeHelper.requireNonNull(constants$1.const$1,"crypto_kdf_hkdf_sha256_expand");
    }
    /**
     * {@snippet :
     * int crypto_kdf_hkdf_sha256_expand(unsigned char* out, size_t out_len, char* ctx, size_t ctx_len, unsigned char prk[32]);
     * }
     */
    public static int crypto_kdf_hkdf_sha256_expand(MemorySegment out, long out_len, MemorySegment ctx, long ctx_len, MemorySegment prk) {
        var mh$ = crypto_kdf_hkdf_sha256_expand$MH();
        try {
            return (int)mh$.invokeExact(out, out_len, ctx, ctx_len, prk);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle crypto_scalarmult_base$MH() {
        return RuntimeHelper.requireNonNull(constants$1.const$3,"crypto_scalarmult_base");
    }
    /**
     * {@snippet :
     * int crypto_scalarmult_base(unsigned char* q, unsigned char* n);
     * }
     */
    public static int crypto_scalarmult_base(MemorySegment q, MemorySegment n) {
        var mh$ = crypto_scalarmult_base$MH();
        try {
            return (int)mh$.invokeExact(q, n);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle crypto_scalarmult$MH() {
        return RuntimeHelper.requireNonNull(constants$1.const$5,"crypto_scalarmult");
    }
    /**
     * {@snippet :
     * int crypto_scalarmult(unsigned char* q, unsigned char* n, unsigned char* p);
     * }
     */
    public static int crypto_scalarmult(MemorySegment q, MemorySegment n, MemorySegment p) {
        var mh$ = crypto_scalarmult$MH();
        try {
            return (int)mh$.invokeExact(q, n, p);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle randombytes_buf$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$1,"randombytes_buf");
    }
    /**
     * {@snippet :
     * void randombytes_buf(void* buf, const size_t size);
     * }
     */
    public static void randombytes_buf(MemorySegment buf, long size) {
        var mh$ = randombytes_buf$MH();
        try {
            mh$.invokeExact(buf, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sodium_bin2hex$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$3,"sodium_bin2hex");
    }
    /**
     * {@snippet :
     * char* sodium_bin2hex(char* hex, const size_t hex_maxlen, unsigned char* bin, const size_t bin_len);
     * }
     */
    public static MemorySegment sodium_bin2hex(MemorySegment hex, long hex_maxlen, MemorySegment bin, long bin_len) {
        var mh$ = sodium_bin2hex$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(hex, hex_maxlen, bin, bin_len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle sodium_hex2bin$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$5,"sodium_hex2bin");
    }
    /**
     * {@snippet :
     * int sodium_hex2bin(unsigned char* bin, const size_t bin_maxlen, char* hex, const size_t hex_len, char* ignore, size_t* bin_len, char** hex_end);
     * }
     */
    public static int sodium_hex2bin(MemorySegment bin, long bin_maxlen, MemorySegment hex, long hex_len, MemorySegment ignore, MemorySegment bin_len, MemorySegment hex_end) {
        var mh$ = sodium_hex2bin$MH();
        try {
            return (int)mh$.invokeExact(bin, bin_maxlen, hex, hex_len, ignore, bin_len, hex_end);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
}


